<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CCA ¬∑ Diagonalizations</title><meta name="title" content="CCA ¬∑ Diagonalizations"/><meta property="og:title" content="CCA ¬∑ Diagonalizations"/><meta property="twitter:title" content="CCA ¬∑ Diagonalizations"/><meta name="description" content="Documentation for Diagonalizations."/><meta property="og:description" content="Documentation for Diagonalizations."/><meta property="twitter:description" content="Documentation for Diagonalizations."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="Diagonalizations logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="Diagonalizations logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Diagonalizations</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Documentation</a></li><li><a class="tocitem" href="../Diagonalizations/">Diagonalizations</a></li><li><span class="tocitem">Filters</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">One dataset (m=1)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pca/">PCA</a></li><li><a class="tocitem" href="../whitening/">Whitening</a></li><li><a class="tocitem" href="../csp/">CSP</a></li><li><a class="tocitem" href="../cstp/">CSTP</a></li><li><a class="tocitem" href="../ajd/">AJD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Two datasets (m=2)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mca/">MCA</a></li><li class="is-active"><a class="tocitem" href>CCA</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Several datasets (m&gt;2)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gmca/">gMCA</a></li><li><a class="tocitem" href="../gcca/">gCCA</a></li><li><a class="tocitem" href="../majd/">mAJD</a></li></ul></li></ul></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Filters</a></li><li><a class="is-disabled">Two datasets (m=2)</a></li><li class="is-active"><a href>CCA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CCA</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/Diagonalizations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Marco-Congedo/Diagonalizations.jl/blob/master/docs/src/cca.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CCA"><a class="docs-heading-anchor" href="#CCA">CCA</a><a id="CCA-1"></a><a class="docs-heading-anchor-permalink" href="#CCA" title="Permalink"></a></h1><p><em>Canonical Correlation Analysis</em> was first proposed by Hotelling (1936) <a href="../">üéì</a>. It can be conceived as the multivariate extension of Pearson&#39;s product-moment correlation, as the bilinear version of <a href="../whitening/#Whitening">Whitening</a> or as the standardized version of <a href="../mca/#MCA">MCA</a>; if MCA maximizes the cross-covariance of two data set, CCA maximizes their correlation. Like the MCA, the CCA corresponds to the situation <span>$m=2$</span> (two datasets) and <span>$k=1$</span> (one observation).</p><p>As per <a href="../mca/#MCA">MCA</a>, Let <span>$X$</span> and <span>$Y$</span> be two <span>$n_x‚ãÖt$</span> and <span>$n_y‚ãÖt$</span> data matrices, where <span>$n_x$</span> and <span>$n_y$</span> are the number of variables in <span>$X$</span> and <span>$Y$</span>, respectively and <span>$t$</span> the number of samples. We assume here too that the samples in <span>$X$</span> and <span>$Y$</span> are synchronized. Let <span>$C_{x}$</span> be the <span>$n_x‚ãÖn_x$</span> covariance matrix of <span>$X$</span> and <span>$C_{y}$</span> be the <span>$n_y‚ãÖn_y$</span> covariance matrix of <span>$Y$</span>. Let also <span>$C_{xy}=\frac{1}{t}X^HY$</span> be the <span>$n_x‚ãÖn_y$</span> <a href="https://en.wikipedia.org/wiki/Cross-covariance">cross-covariance matrix</a>. CCA seeks two matrices <span>$F_x$</span> and <span>$F_y$</span> such that</p><p><span>$\left \{ \begin{array}{rl}F_x^HC_xF_x=I\\F_y^HC_yF_y=I\\F_x^HC_{xy}F_y=Œõ \end{array} \right.$</span>, <span>$\hspace{1cm}$</span> [cca.1]</p><p>where <span>$Œõ$</span> is a <span>$n‚ãÖn$</span> diagonal matrix, with <span>$n=min(n_x, n_y)$</span>. The first components (rows) of <span>$F_x^{H}X$</span> and <span>$F_y^{H}Y$</span> hold the linear combination of <span>$X$</span> and <span>$Y$</span> with maximal correlation, the second the linear combination with maximal residual correlation and so on, subject to constraint [cca.1].</p><p>In matrix form this can be written such as</p><p><span>$\begin{pmatrix} F_x^H &amp; 0\\0 &amp; F_y^H\end{pmatrix} \begin{pmatrix} C_x &amp; C_{xy}\\C_{xy}^H &amp; C_y\end{pmatrix} \begin{pmatrix} F_x &amp; 0\\0 &amp; F_y\end{pmatrix} = \begin{pmatrix} I &amp; Œõ\\Œõ &amp; I\end{pmatrix}$</span>. <span>$\hspace{1cm}$</span> [cca.2]</p><p>If <span>$n_x=n_y$</span>, from [cca.1] it follows</p><p><span>$\left \{ \begin{array}{rl}F_x^{-H}F_x^{-1}=C_x\\F_y^{-H}F_y^{-1}=C_y\\F_x^{-H}F_y^{-1}=C_{xy} \end{array} \right.$</span>, <span>$\hspace{1cm}$</span> [cca.3]</p><p>that is, CCA is a special kind of <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/linearAlgebra/#PosDefManifold.frf">full-rank factorization</a> of <span>$C_x$</span> and <span>$C_y$</span>.</p><p>Equating the left hand sides of the first two expressions in [cca.1] and setting <span>$E_x=B_xB_y^{-H}$</span>, <span>$E_y=B_yB_x^{-H}$</span>, it follows</p><p><span>$\left \{ \begin{array}{rl}C_x=E_xC_yE_x^H\\C_y=E_yC_xE_y^H \end{array} \right.$</span>, <span>$\hspace{1cm}$</span> [cca.4]</p><p>that is, CCA defines a linear transormation linking the covariance matrices of two data sets.</p><p>Since it maximizes the correlation, differently from <a href="../mca/#MCA">MCA</a>, CCA is not sensitive to the amplitude of the two processes. This should be kept in mind, as the correlation of two signals may be high even if the amplitude of one of the two signal is very low, say, at the noise level. In such a case the resulting correlation is meaningless.</p><p>The <em>accumulated regularized eigenvalues</em> (arev) for the CCA are defined as</p><p><span>$œÉ_j=\sum_{i=1}^j{œÉ_i}$</span>, for <span>$j=[1 \ldots n]$</span>, <span>$\hspace{1cm}$</span> [cca.5]</p><p>where <span>$œÉ_i$</span> is given by</p><p><span>$œÉ_p=\frac{\sum_{i=1}^pŒª_i}{œÉ_{TOT}}$</span>  <span>$\hspace{1cm}$</span> [cca.6]</p><p>and <span>$Œª_i$</span> are the singular values in <span>$Œõ$</span> of [cca.1].</p><p>For setting the subspace dimension <span>$p$</span> manually, set the <code>eVar</code> optional keyword argument of the CCA constructors either to an integer or to a real number, this latter establishing <span>$p$</span> in conjunction with argument <code>eVarMeth</code> using the <code>arev</code> vector (see <a href="../Diagonalizations/#subspace-dimension">subspace dimension</a>). By default, <code>eVar</code> is set to 0.999.</p><p><strong>Solution</strong></p><p>If <span>$n_x=n_y$</span> the solutions to the CCA <span>$B_x$</span> and <span>$B_y$</span> are given by the eigenvector matrix of (non-symmetric) matrices <span>$C_x^{-1}C_{xy}C_y^{-1}C_{yx}$</span> and <span>$C_y^{-1}C_{yx}C_x^{-1}C_{xy}$</span>, respecively.</p><p>A numerically preferable solution, accommodating also the case <span>$n_x‚â†n_y$</span>, is the following two-step procedure, which is the one here implemented:</p><ol><li>get some whitening matrices <span>$\hspace{0.1cm}(W_x, W_y)\hspace{0.1cm}$</span> such that <span>$\hspace{0.1cm}W_x^HC_xW_x=I\hspace{0.1cm}$</span> and <span>$\hspace{0.1cm}W_y^HC_yW_y=I$</span></li><li>do <span>$\hspace{0.1cm}\textrm{SVD}(W_x^HC_{xy}W_y)=U_xŒõU_y^{H}$</span></li></ol><p>The solutions are <span>$\hspace{0.1cm}B_x=W_xU_x\hspace{0.1cm}$</span> and <span>$\hspace{0.1cm}B_y=W_yU_y\hspace{0.1cm}$</span>.</p><p><strong>Constructors</strong></p><p>Three constructors are available (see here below). The constructed <a href="../Diagonalizations/#LinearFilter">LinearFilter</a> object holding the CCA will have fields:</p><p><code>.F[1]</code>: matrix <span>$\widetilde{B}_x=[b_{x1} \ldots b_{xp}]$</span> with the columns holding the first <span>$p$</span> vectors in <span>$B_x$</span>.</p><p><code>.F[2]</code>: matrix <span>$\widetilde{B}_y=[b_{y1} \ldots b_{yp}]$</span> with the columns holding the first <span>$p$</span> vectors in <span>$B_y$</span>.</p><p><code>.iF[1]</code>: the left-inverse of <code>.F[1]</code></p><p><code>.iF[2]</code>: the left-inverse of <code>.F[2]</code></p><p><code>.D</code>: the leading <span>$p‚ãÖp$</span> block of <span>$Œõ$</span>, i.e., the correlation values associated to <code>.F</code> in diagonal form.</p><p><code>.eVar</code>: the explained variance for the chosen value of <span>$p$</span>, defined in [cca.6].</p><p><code>.ev</code>: the vector <code>diag(Œõ)</code> holding all <span>$n$</span> correlation values.</p><p><code>.arev</code>: the accumulated regularized eigenvalues, defined in [cca.5].</p><article><details class="docstring" open="true"><summary id="Diagonalizations.cca"><a class="docstring-binding" href="#Diagonalizations.cca"><code>Diagonalizations.cca</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">(1)
function cca(Cx :: SorH, Cy :: SorH, Cxy :: Mat;
             eVarCx   :: TeVaro=‚óã,
             eVarCy   :: TeVaro=‚óã,
             eVar     :: TeVaro=‚óã,
             eVarMeth :: Function=searchsortedfirst,
             simple   :: Bool=false)

(2)
function cca(X::Mat, Y::Mat;
             covEst   :: StatsBase.CovarianceEstimator=SCM,
             dims     :: Into = ‚óã,
             meanX    :: Tmean = 0,
             meanY    :: Tmean = 0,
             wX       :: Tw = ‚óã,
             wY       :: Tw = ‚óã,
             wXY      :: Tw = ‚óã,
          eVarCx   :: TeVaro = ‚óã,
          eVarCy   :: TeVaro = ‚óã,
          eVar     :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          simple   :: Bool = false)

(3)
function cca(ùêó::VecMat, ùêò::VecMat;
             covEst   :: StatsBase.CovarianceEstimator=SCM,
             dims     :: Into = ‚óã,
             meanX    :: Into = 0,
             meanY    :: Into = 0,
          eVarCx   :: TeVaro = ‚óã,
          eVarCy   :: TeVaro = ‚óã,
          eVar     :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          simple   :: Bool = false,
       metric   :: Metric = Euclidean,
       wCx      :: Vector = [],
       wCy      :: Vector = [],
       ‚úìw       :: Bool = true,
       initCx   :: SorHo = nothing,
       initCy   :: SorHo = nothing,
       tol      :: Real = 0.,
       verbose  :: Bool = false)</code></pre><p>Return a <a href="../Diagonalizations/#LinearFilter">LinearFilter</a> object:</p><p><strong>(1) Canonical correlation analysis</strong> with, as input, real or complex:</p><ul><li>covariance matrix <code>Cx</code> of dimension <span>$n_x‚ãÖn_x$</span>,</li><li>covariance matrix <code>Cy</code> of dimension <span>$n_y‚ãÖn_y$</span> and</li><li>cross-covariance matrix <code>Cxy</code> of dimension <span>$n_x‚ãÖn_y$</span>.</li></ul><p><code>Cx</code> and <code>Cy</code> must be flagged as <code>Symmetric</code>, if real or <code>Hermitian</code>, if real or complex, see <a href="../Diagonalizations/#data-input">data input</a>. Instead <code>Cxy</code> is a generic <code>Matrix</code> object since it is not symmetric/Hermitian, left alone square.</p><p><code>eVarCx</code>, <code>eVarCy</code>, <code>eVar</code> and <code>eVarMeth</code> are keyword optional arguments for defining the <a href="../Diagonalizations/#subspace-dimension">subspace dimension</a> <span>$p$</span>. Particularly:</p><ul><li><code>eVarCx</code> and <code>eVarCy</code> are used to determine a subspace dimension in the whitening of <code>Cx</code> and <code>Cy</code>, i.e., in the first step of the two-step procedure descrived above in the <strong>solution</strong> section.</li><li><code>eVar</code> is used to determine the final subspace dimension using the <code>.arev</code> vector given by Eq. [cca.5] here above.</li><li><code>eVarMeth</code> applies to <code>eVarCx</code>, <code>eVarCy</code> and <code>eVar</code>.</li></ul><p>The default values are:</p><ul><li><code>eVarCx=0.999</code></li><li><code>eVarCy=0.999</code></li><li><code>eVar=0.999</code></li><li><code>eVarMeth=searchsortedfirst</code></li></ul><p>If <code>simple</code> is set to <code>true</code>, <span>$p$</span> is set equal to <span>$min(n_x, n_y)$</span> and only the fields <code>.F</code> and <code>.iF</code> are written in the constructed object. This option is provided for low-level work when you don&#39;t need to define a subspace dimension or you want to define it by your own methods.</p><p><strong>(2) Canonical correlation analysis</strong> with real or complex data matrices <code>X</code> and <code>Y</code> as input.</p><p><code>covEst</code>, <code>dims</code>, <code>meanX</code>, <code>meanY</code>,  <code>wX</code>, <code>wY</code> and <code>wXY</code> are optional keyword arguments to regulate the estimation of the covariance matrices of <code>X</code> and <code>Y</code> and their cross-covariance matrix <span>$C_{xy}$</span>. Particularly (See <a href="../Diagonalizations/#covariance-matrix-estimations">covariance matrix estimations</a>),</p><ul><li><code>meanX</code> is the <code>mean</code> argument for data matrix <code>X</code>.</li><li><code>meanY</code> is the <code>mean</code> argument for data matrix <code>Y</code>.</li><li><code>wX</code> is the <code>w</code> argument for estimating a weighted covariance matrix <span>$C_x$</span>.</li><li><code>wY</code> is the <code>w</code> argument for estimating a weighted covariance matrix <span>$C_y$</span>.</li><li><code>wXY</code> is the <code>w</code> argument for estimating a weighted  cross-covariance matrix <span>$C_{XY}$</span>.</li><li><code>covEst</code> applies only to the estimation of <span>$C_x$</span> and <span>$C_y$</span>.</li></ul><p>Once <span>$C_x$</span>, <span>$C_y$</span> and <span>$C_{xy}$</span> estimated, method (1) is invoked with optional keyword arguments <code>eVar</code>, <code>eVarCx</code>, <code>eVarCy</code>, <code>eVarMeth</code> and <code>simple</code>. See method (1) for details.</p><p><strong>(3) Canonical correlation analysis</strong> with two vectors of real or complex data matrices <code>ùêó</code> and <code>ùêò</code> as input. <code>ùêó</code> and <code>ùêò</code> must hold the same number of matrices and corresponding pairs of matrices therein must comprise the same number of samples.</p><p><code>covEst</code>, <code>dims</code>, <code>meanX</code> and <code>meanY</code> are optional keyword arguments to regulate the estimation of the covariance matrices of all matrices in <code>ùêó</code> and <code>ùêò</code> and the cross-covariance matrices for all pairs of their corresponding data matrices. See method (2) and <a href="../Diagonalizations/#covariance-matrix-estimations">covariance matrix estimations</a>.</p><p>A mean of these covariance matrices is computed. For the cross-covariance matrices the arithmetic mean is used. For the covariance matrices of <code>ùêó</code> and <code>ùêò</code>, optional keywords arguments <code>metric</code>, <code>wCx</code>, <code>wCy</code>, <code>‚úìw</code>, <code>initCx</code>, <code>initCy</code>, <code>tol</code> and <code>verbose</code> are used to allow non-Euclidean mean estimations. Particularly (see <a href="../Diagonalizations/#mean-covariance-matrix-estimations">mean covariance matrix estimations</a>),</p><ul><li><code>wCx</code> are the weights for the covariance matrices of <code>ùêó</code>,</li><li><code>wCy</code> are the weights for the covariance matrices of <code>ùêò</code>,</li><li><code>initCx</code> is the initialization for the mean of the covariance matrices of <code>ùêó</code>,</li><li><code>initCy</code> is the initialization for the mean of the covariance matrices of <code>ùêò</code>.</li></ul><p>By default, the arithmetic mean is computed.</p><p>Once the mean covariance and cross-covariance matrices are estimated, method (1) is invoked with optional keyword arguments <code>eVarCx</code>, <code>eVarCy</code>, <code>eVar</code>, <code>eVarMeth</code> and <code>simple</code>. See method (1) for details.</p><p><strong>See also:</strong> <a href="../whitening/#Whitening">Whitening</a>, <a href="../mca/#MCA">MCA</a>, <a href="../gcca/#gCCA">gCCA</a>, <a href="../majd/#mAJD">mAJD</a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">using Diagonalizations, LinearAlgebra, PosDefManifold, Test

# Method (1) real
n, t=10, 100
X=genDataMatrix(n, t)
Y=genDataMatrix(n, t)
Cx=Symmetric((X*X&#39;)/t)
Cy=Symmetric((Y*Y&#39;)/t)
Cxy=(X*Y&#39;)/t
cC=cca(Cx, Cy, Cxy, simple=true)
@test cC.F[1]&#39;*Cx*cC.F[1]‚âàI
@test cC.F[2]&#39;*Cy*cC.F[2]‚âàI
D=cC.F[1]&#39;*Cxy*cC.F[2]
@test norm(D-Diagonal(D))+1. ‚âà 1.

# Method (1) complex
Xc=genDataMatrix(ComplexF64, n, t)
Yc=genDataMatrix(ComplexF64, n, t)
Cxc=Hermitian((Xc*Xc&#39;)/t)
Cyc=Hermitian((Yc*Yc&#39;)/t)
Cxyc=(Xc*Yc&#39;)/t
cCc=cca(Cxc, Cyc, Cxyc, simple=true)
@test cCc.F[1]&#39;*Cxc*cCc.F[1]‚âàI
@test cCc.F[2]&#39;*Cyc*cCc.F[2]‚âàI
Dc=cCc.F[1]&#39;*Cxyc*cCc.F[2]
@test norm(Dc-Diagonal(Dc))+1. ‚âà 1.


# Method (2) real
cXY=cca(X, Y, simple=true)
@test cXY.F[1]&#39;*Cx*cXY.F[1]‚âàI
@test cXY.F[2]&#39;*Cy*cXY.F[2]‚âàI
D=cXY.F[1]&#39;*Cxy*cXY.F[2]
@test norm(D-Diagonal(D))+1. ‚âà 1.
@test cXY==cC

# Method (2) complex
cXYc=cca(Xc, Yc, simple=true)
@test cXYc.F[1]&#39;*Cxc*cXYc.F[1]‚âàI
@test cXYc.F[2]&#39;*Cyc*cXYc.F[2]‚âàI
Dc=cXYc.F[1]&#39;*Cxyc*cXYc.F[2]
@test norm(Dc-Diagonal(Dc))+1. ‚âà 1.
@test cXYc==cCc


# Method (3) real
# canonical correlation analysis of the average covariance and cross-covariance
k=10
Xset=[genDataMatrix(n, t) for i=1:k]
Yset=[genDataMatrix(n, t) for i=1:k]

c=cca(Xset, Yset)

# ... selecting subspace dimension allowing an explained variance = 0.9
c=cca(Xset, Yset; eVar=0.9)

# ... subtracting the mean from the matrices in Xset and Yset
c=cca(Xset, Yset; meanX=nothing, meanY=nothing, eVar=0.9)

# cca on the average of the covariance and cross-covariance matrices
# computed along dims 1
c=cca(Xset, Yset; dims=1, eVar=0.9)

# name of the filter
c.name

using Plots
# plot regularized accumulated eigenvalues
plot(c.arev)

# plot the original covariance and cross-covariance matrices
# and their transformed counterpart
 CxyMax=maximum(abs.(Cxy));
 h1 = heatmap(Cxy, clim=(-CxyMax, CxyMax), title=&quot;Cxy&quot;, yflip=true, c=:bluesreds);
 D=cC.F[1]&#39;*Cxy*cC.F[2];
 Dmax=maximum(abs.(D));
 h2 = heatmap(D, clim=(0, Dmax), title=&quot;F1&#39;CxyF2&quot;, yflip=true, c=:amp);
 CxMax=maximum(abs.(Cx));
 h3 = heatmap(Cx, clim=(-CxMax, CxMax), title=&quot;Cx&quot;, yflip=true, c=:bluesreds);
 h4 = heatmap(cC.F[1]&#39;*Cx*cC.F[1], clim=(0, 1), title=&quot;F1&#39;CxF1&quot;, yflip=true, c=:amp);
 CyMax=maximum(abs.(Cy));
 h5 = heatmap(Cy, clim=(-CyMax, CyMax), title=&quot;Cy&quot;, yflip=true, c=:bluesreds);
 h6 = heatmap(cC.F[2]&#39;*Cy*cC.F[2], clim=(0, 1), title=&quot;F2&#39;CyF2&quot;, yflip=true, c=:amp);
 üìà=plot(h3, h5, h1, h4, h6, h2, size=(800,400))
# savefig(üìà, homedir()*&quot;\Documents\Code\julia\Diagonalizations\docs\src\assets\FigCCA.png&quot;)
</code></pre><p><img src="../assets/FigCCA.png" alt="Figure CCA"/></p><pre><code class="language-julia hljs"># Method (3) complex
# canonical correlation analysis of the average covariance and cross-covariance
k=10
Xcset=[genDataMatrix(ComplexF64, n, t) for i=1:k]
Ycset=[genDataMatrix(ComplexF64, n, t) for i=1:k]

cc=cca(Xcset, Ycset)

# ... selecting subspace dimension allowing an explained variance = 0.9
cc=cca(Xcset, Ycset; eVar=0.9)

# ... subtracting the mean from the matrices in Xset and Yset
cc=cca(Xcset, Ycset; meanX=nothing, meanY=nothing, eVar=0.9)

# cca on the average of the covariance and cross-covariance matrices
# computed along dims 1
cc=cca(Xcset, Ycset; dims=1, eVar=0.9)

# name of the filter
cc.name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Diagonalizations.jl/blob/cd91d22929ce4207e93ee25a73f69540125098d3/src/cca.jl#L258-L504">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mca/">¬´ MCA</a><a class="docs-footer-nextpage" href="../gmca/">gMCA ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 14:01">Saturday 14 February 2026</span>. Using Julia version 1.11.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
