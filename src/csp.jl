#   Unit "csp.jl" of the Diagonalization.jl Package for Julia language
#
#   MIT License
#   Copyright (c) 2019,
#   Marco Congedo, CNRS, Grenoble, France:
#   https://sites.google.com/site/marcocongedo/home

# ? CONTENTS :
#   This unit implements Common Spatial Pattern (CSP) filters,
#   that is, filters based on the generalized eigendecomposition


"""
```
(1)
function csp(C‚ÇÅ :: SorH, C‚ÇÇ :: SorH;
             eVar     :: TeVaro = ‚óã,
             eVarC    :: TeVaro = ‚óã,
             eVarMeth :: Function = searchsortedfirst,
             selMeth  :: Symbol = :extremal,
             simple   :: Bool = false)

(2)
function csp(X‚ÇÅ :: Mat, X‚ÇÇ :: Mat;
             covEst   :: StatsBase.CovarianceEstimator = SCM,
             dims     :: Into = ‚óã,
             meanX‚ÇÅ   :: Tmean = 0,
             meanX‚ÇÇ   :: Tmean = 0,
             wX‚ÇÅ      :: Tw = ‚óã,
             wX‚ÇÇ      :: Tw = ‚óã,
          eVar     :: TeVaro = ‚óã,
          eVarC    :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          selMeth  :: Symbol = :extremal,
          simple   :: Bool = false)

(3)
function csp(ùêó‚ÇÅ::VecMat, ùêó‚ÇÇ::VecMat;
             covEst   :: StatsBase.CovarianceEstimator = SCM,
             dims     :: Into = ‚óã,
             meanX‚ÇÅ   :: Into = 0,
             meanX‚ÇÇ   :: Into = 0,
          eVar     :: TeVaro = ‚óã,
          eVarC    :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          selMeth  :: Symbol = :extremal,
          simple   :: Bool = false,
       metric   :: Metric = Euclidean,
       w‚ÇÅ       :: Vector = [],
       w‚ÇÇ       :: Vector = [],
       ‚úìw       :: Bool = true,
       init‚ÇÅ    :: SorHo = nothing,
       init‚ÇÇ    :: SorHo = nothing,
       tol      :: Real = 0.,
       verbose  :: Bool = false)
```

Return a [LinearFilter](@ref) object:

**(1) Common spatial pattern**
with covariance matrices `C_1` and `C_2` of dimension
``n‚ãÖn`` as input. The subscript of the covariance matrices refers to the `dims`
used to compute it (see above).

`eVar`, `eVarC` and `eVarMeth` are keyword optional arguments
for defining the [subspace dimension](@ref) ``p``. Particularly:
-  By default, the two-step procedure described above is used to find the
   solution. In this case `eVarC` is used for defining the subspace dimension of
   the whitening step. If `eVarC=0.` is passed,
   the solution will be find by the generalized eigenvalue-eigenvector procedure.
- `eVar` is the keyword optional argument for defining the
   [subspace dimension](@ref) ``p`` using the `.arev` vector
   given by [csp.5].
- `eVarMeth` applies to both `eVarC` and `eVar`. The default value is
   `evarMeth=searchsortedfirst`.

if `selMeth=:extremal` (default) use case **a) Separating two classes**
described above is considered. Any other symbol for `selMeth` will instruct
to consider instead the use case **b) Enhance the signal-to-noise ratio**.

If `simple` is set to `true`, ``p`` is set equal to ``n``
and only the fields `.F` and `.iF` are written in the constructed object.
This option is provided for low-level work when you don't need to define
a subspace dimension or you want to define it by your own methods.

**(2) Common spatial pattern**
with data matrices `X‚ÇÅ` and `X‚ÇÇ` as input.

`X‚ÇÅ` and `X‚ÇÇ` are real or complex data matrices.

`covEst`, `dims`, `meanX‚ÇÅ`, `meanX‚ÇÇ`,  `wX‚ÇÅ` and `wX‚ÇÇ` are optional
keyword arguments to regulate the estimation of the
covariance matrices ``(C_1, C_2)`` of (`X‚ÇÅ`, `X‚ÇÇ`).
Particularly (See [covariance matrix estimations](@ref)),
- `meanX‚ÇÅ` is the `mean` argument for data matrix `X‚ÇÅ`.
- `meanX‚ÇÇ` is the `mean` argument for data matrix `X‚ÇÇ`.
- `wX‚ÇÅ` is the `w` argument for estimating a weighted covariance matrix for `X‚ÇÅ`.
- `wX‚ÇÇ` is the `w` argument for estimating a weighted covariance matrix for `X‚ÇÇ`.
- `covEst` applies to the estimations of both covariance matrices.

Once the two covariance matrices ``C_1`` and ``C_2`` estimated,
method (1) is invoked with optional keyword arguments
`eVar`, `eVarC`, `eVarMeth`, `selMeth` and `simple`.
See method (1) for details.


**(3) Common spatial pattern**
with two vectors of data matrices
`ùêó‚ÇÅ` and `ùêó‚ÇÇ` as input.

`ùêó‚ÇÅ` and `ùêó‚ÇÇ` do not need to hold the same number
of matrices and the number of samples in the matrices they contain
is arbitrary.

`covEst`, `dims`, `meanX‚ÇÅ` and `meanX‚ÇÇ` are optional
keyword arguments to regulate the estimation of the
covariance matrices for all matrices in `ùêó‚ÇÅ` and `ùêó‚ÇÇ`.
See method (2) and [covariance matrix estimations](@ref).

A mean covariance matrix is computed separatedly from the covariance matrices
computed from the data matrices in `ùêó‚ÇÅ` and `ùêó‚ÇÇ`,
using optional keywords arguments
`metric`, `w‚ÇÅ`, `w‚ÇÇ`, `‚úìw`,
`init‚ÇÅ`, `init‚ÇÇ`, `tol` and `verbose`. Particularly
(see [mean covariance matrix estimations](@ref)),
- `w‚ÇÅ` are the weights for the covariance matrices computed from `ùêó‚ÇÅ`,
- `w‚ÇÇ` are the weights for the covariance matrices computed from `ùêó‚ÇÇ`,
- `init‚ÇÅ` is the initialization for the mean of the covariance matrices computed from `ùêó‚ÇÅ`,
- `init‚ÇÇ` is the initialization for the mean of the covariance matrices computed from `ùêó‚ÇÇ`.
By default, the arithmetic mean is computed.

**See also:** [CSTP](@ref), [PCA](@ref), [AJD](@ref), [mAJD](@ref).

**Examples:**

```
using Diagonalizations, LinearAlgebra, PosDefManifold, Test

# Method (1) real
t, n=50, 10
X1=genDataMatrix(n, t)
X2=genDataMatrix(n, t)
Cx1=Symmetric((X1*X1')/t)
Cx2=Symmetric((X2*X2')/t)
C=Cx1+Cx2
cC=csp(Cx1, Cx2; simple=true)
Dx1=cC.F'*Cx1*cC.F
@test norm(Dx1-Diagonal(Dx1))+1‚âà1.
Dx2=cC.F'*Cx2*cC.F
@test norm(Dx2-Diagonal(Dx2))+1‚âà1.
@test cC.F'*C*cC.F‚âàI
@test norm(Dx1-(I-Dx2))+1‚âà1.

# Method (1) complex
t, n=50, 10
X1c=genDataMatrix(ComplexF64, n, t)
X2c=genDataMatrix(ComplexF64, n, t)
Cx1c=Hermitian((X1c*X1c')/t)
Cx2c=Hermitian((X2c*X2c')/t)
Cc=Cx1c+Cx2c
cCc=csp(Cx1c, Cx2c; simple=true)
Dx1c=cCc.F'*Cx1c*cCc.F
@test norm(Dx1c-Diagonal(Dx1c))+1. ‚âà 1.
Dx2c=cCc.F'*Cx2c*cCc.F
@test norm(Dx2c-Diagonal(Dx2c))+1. ‚âà 1.
@test cCc.F'*Cc*cCc.F‚âàI
@test norm(Dx1c-(I-Dx2c))+1. ‚âà 1.


# Method (2) real
c12=csp(X1, X2, simple=true)
Dx1=c12.F'*Cx1*c12.F
@test norm(Dx1-Diagonal(Dx1))+1‚âà1.
Dx2=c12.F'*Cx2*c12.F
@test norm(Dx2-Diagonal(Dx2))+1‚âà1.
@test c12.F'*C*c12.F‚âàI
@test norm(Dx1-(I-Dx2))+1‚âà1.
@test cC==c12

# Method (2) complex
c12c=csp(X1c, X2c, simple=true)
Dx1c=c12c.F'*Cx1c*c12c.F
@test norm(Dx1c-Diagonal(Dx1c))+1. ‚âà 1.
Dx2c=c12c.F'*Cx2c*c12c.F
@test norm(Dx2c-Diagonal(Dx2c))+1. ‚âà 1.
@test c12c.F'*Cc*c12c.F‚âàI
@test norm(Dx1c-(I-Dx2c))+1. ‚âà 1.
@test cCc==c12c


# Method (3) real
# CSP of the average covariance matrices
k=10
Xset=[genDataMatrix(n, t) for i=1:k]
Yset=[genDataMatrix(n, t) for i=1:k]

c=csp(Xset, Yset)

# ... selecting subspace dimension allowing an explained variance = 0.9
c=csp(Xset, Yset; eVar=0.9)

# ... subtracting the mean from the matrices in Xset and Yset
c=csp(Xset, Yset; meanX‚ÇÅ=nothing, meanX‚ÇÇ=nothing, eVar=0.9)

# csp on the average of the covariance and cross-covariance matrices
# computed along dims 1
c=csp(Xset, Yset; dims=1, eVar=0.9)

# name of the filter
c.name

using Plots
# plot regularized accumulated eigenvalues
plot(c.arev)


# plot the original covariance matrices and the transformed counterpart
# example when argument `selMeth` is `extremal` (default): 2-class separation
 cC=csp(Cx1, Cx2)
 Cx1Max=maximum(abs.(Cx1));
 h1 = heatmap(Cx1, clim=(-Cx1Max, Cx1Max), title="Cx1", yflip=true, c=:bluesreds);
 h2 = heatmap(cC.F'*Cx1*cC.F, clim=(0, 1), title="F'*Cx1*F", yflip=true, c=:amp);
 Cx2Max=maximum(abs.(Cx2));
 h3 = heatmap(Cx2, clim=(-Cx2Max, Cx2Max), title="Cx2", yflip=true, c=:bluesreds);
 h4 = heatmap(cC.F'*Cx2*cC.F, clim=(0, 1), title="F'*Cx2*F", yflip=true, c=:amp);
 CMax=maximum(abs.(C));
 h5 = heatmap(C, clim=(-CMax, CMax), title="Cx1+Cx2", yflip=true, c=:bluesreds);
 h6 = heatmap(cC.F'*C*cC.F, clim=(0, 1), title="F'*(Cx1+Cx2)*F", yflip=true, c=:amp);
 üìà=plot(h1, h3, h5, h2, h4, h6, size=(800,400))
# savefig(üìà, homedir()*"\\Documents\\Code\\julia\\Diagonalizations\\docs\\src\\assets\\FigCSP1.png")
```

 ![Figure CSP1](assets/FigCSP1.png)

```
# example when argument `selMeth` is different from `extremal`: enhance snr
 cC=csp(Cx1, Cx2; selMeth=:enhaceSNR)
 Cx1Max=maximum(abs.(Cx1));
 h1 = heatmap(Cx1, clim=(-Cx1Max, Cx1Max), title="Cx1", yflip=true, c=:bluesreds);
 h2 = heatmap(cC.F'*Cx1*cC.F, clim=(0, 1), title="F'*Cx1*F", yflip=true, c=:amp);
 Cx2Max=maximum(abs.(Cx2));
 h3 = heatmap(Cx2, clim=(-Cx2Max, Cx2Max), title="Cx2", yflip=true, c=:bluesreds);
 h4 = heatmap(cC.F'*Cx2*cC.F, clim=(0, 1), title="F'*Cx2*F", yflip=true, c=:amp);
 CMax=maximum(abs.(C));
 h5 = heatmap(C, clim=(-CMax, CMax), title="Cx1+Cx2", yflip=true, c=:bluesreds);
 h6 = heatmap(cC.F'*C*cC.F, clim=(0, 1), title="F'*(Cx1+Cx2)*F", yflip=true, c=:amp);
 üìâ=plot(h1, h3, h5, h2, h4, h6, size=(800,400))
# savefig(üìâ, homedir()*"\\Documents\\Code\\julia\\Diagonalizations\\docs\\src\\assets\\FigCSP2.png")

```

 ![Figure CSP2](assets/FigCSP2.png)

```
# Method (3) complex
# CSP of the average covariance matrices
k=10
Xsetc=[genDataMatrix(ComplexF64, n, t) for i=1:k]
Ysetc=[genDataMatrix(ComplexF64, n, t) for i=1:k]

cc=csp(Xsetc, Ysetc)

# ... selecting subspace dimension allowing an explained variance = 0.9
cc=csp(Xsetc, Ysetc; eVar=0.9)

# ... subtracting the mean from the matrices in Xset and Yset
cc=csp(Xsetc, Ysetc; meanX‚ÇÅ=nothing, meanX‚ÇÇ=nothing, eVar=0.9)

# csp on the average of the covariance and cross-covariance matrices
# computed along dims 1
cc=csp(Xsetc, Ysetc; dims=1, eVar=0.9)

# name of the filter
cc.name
```
"""
function csp(C‚ÇÅ :: SorH, C‚ÇÇ :: SorH;
             eVar     :: TeVaro = ‚óã,
             eVarC    :: TeVaro = ‚óã,
             eVarMeth :: Function = searchsortedfirst,
             selMeth  :: Symbol = :extremal,
             simple   :: Bool = false)

  #println(eVar)
  size(C‚ÇÅ, 1)==size(C‚ÇÅ, 2) || throw(ArgumentError(üìå*", csp function: Matrix `C‚ÇÅ` must be square"))
  size(C‚ÇÇ, 1)==size(C‚ÇÇ, 2) || throw(ArgumentError(üìå*", csp function: Matrix `C‚ÇÇ` must be square"))
  size(C‚ÇÅ)==size(C‚ÇÇ) || throw(ArgumentError(üìå*", csp function: Matrices `C‚ÇÅ` and `C‚ÇÇ` must have the same size"))

  args=("Common Spatial Pattern", false)

  if eVarC‚â†‚óã && eVarC‚âà0. # use gevd, which also actually whitens C1+C2
     Œª, U = eig(C‚ÇÅ, C‚ÇÅ+C‚ÇÇ)
     Œª = _checkŒª(Œª) # make sure no imaginary noise is present (fro complex data)

     simple ? LF(U, inv(U), Diagonal(Œª), ‚óã, ‚óã, ‚óã, args...) :
     begin
        eVar, D, U, p, arev=_ssdcsp!(eVar, Œª, U, _minDim(C‚ÇÅ, C‚ÇÇ), eVarMeth, selMeth) # subspace dimension
        LF(U, pinv(U), D, eVar, Œª, arev, args...)
     end
  else
     w=whitening(C‚ÇÅ+C‚ÇÇ; eVar=eVarC, eVarMeth=eVarMeth, simple=true)

     Œª, U = eig(Hermitian(w.F'*C‚ÇÅ*w.F)) # get evd of whitened C1
     # Hermitian is necessary for complex data
     Œª = _checkŒª(Œª) # make sure no imaginary noise is present (fro complex data)

     simple ? LF(w.F*U, U'*w.iF, Diagonal(Œª), ‚óã, ‚óã, ‚óã, args...) :
     begin
        eVar, D, U, p, arev=_ssdcsp!(eVar, Œª, U, _minDim(C‚ÇÅ, C‚ÇÇ), eVarMeth, selMeth) # subspace dimension
        LF(w.F*U, U'*w.iF, D, eVar, Œª, arev, args...)
     end
  end
end



function csp(X‚ÇÅ :: Mat, X‚ÇÇ :: Mat;
             covEst   :: StatsBase.CovarianceEstimator = SCM,
             dims     :: Into = ‚óã,
             meanX‚ÇÅ   :: Tmean = 0,
             meanX‚ÇÇ   :: Tmean = 0,
             wX‚ÇÅ      :: Tw = ‚óã,
             wX‚ÇÇ      :: Tw = ‚óã,
          eVar     :: TeVaro = ‚óã,
          eVarC    :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          selMeth  :: Symbol = :extremal,
          simple   :: Bool = false)

   if dims===‚óã dims=_set_dims(X‚ÇÅ, X‚ÇÇ) end

   _check_data(X‚ÇÅ, dims, meanX‚ÇÅ, wX‚ÇÅ)===‚óã && return
   C‚ÇÅ=_cov(X‚ÇÅ, covEst, dims, meanX‚ÇÅ, wX‚ÇÅ)

   _check_data(X‚ÇÇ, dims, meanX‚ÇÇ, wX‚ÇÇ)===‚óã && return
   C‚ÇÇ=_cov(X‚ÇÇ, covEst, dims,  meanX‚ÇÇ, wX‚ÇÇ)

   csp(C‚ÇÅ, C‚ÇÇ; eVar=eVar, eVarC=eVarC, eVarMeth=eVarMeth,
       selMeth=selMeth, simple=simple)
end


function csp(ùêó‚ÇÅ::VecMat, ùêó‚ÇÇ::VecMat;
             covEst   :: StatsBase.CovarianceEstimator = SCM,
             dims     :: Into = ‚óã,
             meanX‚ÇÅ   :: Into = 0,
             meanX‚ÇÇ   :: Into = 0,
          eVar     :: TeVaro = ‚óã,
          eVarC    :: TeVaro = ‚óã,
          eVarMeth :: Function = searchsortedfirst,
          selMeth  :: Symbol = :extremal,
          simple   :: Bool = false,
       metric   :: Metric = Euclidean,
       w‚ÇÅ       :: Vector = [],
       w‚ÇÇ       :: Vector = [],
       ‚úìw       :: Bool = true,
       init‚ÇÅ    :: SorHo = nothing,
       init‚ÇÇ    :: SorHo = nothing,
       tol      :: Real = 0.,
       verbose  :: Bool = false)

   Metric==VonNeumann && throw(ArgumentError(üìå*", csp function: A solution for the mean is not available for the Von Neumann metric. Use another metric as `metric` argument"))
   if dims===‚óã dims=_set_dims(ùêó‚ÇÅ, ùêó‚ÇÇ) end

   ùêÇ‚ÇÅ= _cov(ùêó‚ÇÅ; covEst=covEst, dims=dims, meanX=meanX‚ÇÅ)
   ùêÇ‚ÇÇ= _cov(ùêó‚ÇÇ; covEst=covEst, dims=dims, meanX=meanX‚ÇÇ)

   csp(mean(metric, ùêÇ‚ÇÅ;
            w = w‚ÇÅ, ‚úìw = ‚úìw,
            init = init‚ÇÅ===‚óã ? ‚óã : Hermitian(init‚ÇÅ), #just init‚ÇÅ here when you upfate PodDefManifold
            tol = tol, verbose = verbose),
       mean(metric, ùêÇ‚ÇÇ;
            w = w‚ÇÇ, ‚úìw = ‚úìw,
            init = init‚ÇÇ===‚óã ? ‚óã : Hermitian(init‚ÇÇ), #just init‚ÇÇ here when you upfate PodDefManifold
            tol = tol, verbose = verbose);
       eVar=eVar, eVarC=eVarC, eVarMeth=eVarMeth,
       selMeth=selMeth, simple=simple)
end



"""
```
(1)
function cstp( X :: Mat, C‚Çç‚ÇÅ‚Çé :: SorH, C‚Çç‚ÇÇ‚Çé :: SorH;
               eVar     :: TeVaro = ‚óã,
               eVarC    :: TeVaro = ‚óã,
               eVarMeth :: Function = searchsortedfirst,
               simple   :: Bool = false)

(2)
function cstp( ùêó::VecMat;
               covEst   :: StatsBase.CovarianceEstimator = SCM,
               meanX    :: Into = 0,
            eVar     :: TeVaro = ‚óã,
            eVarC    :: TeVaro = ‚óã,
            eVarMeth :: Function = searchsortedfirst,
            simple   :: Bool = false,
         metric   :: Metric = Euclidean,
         w        :: Vector = [],
         ‚úìw       :: Bool = true,
         init1    :: SorHo = nothing,
         init2    :: SorHo = nothing,
         tol      :: Real = 0.,
         verbose  :: Bool = false)
```

Return a [LinearFilter](@ref) object:

(1)
**Common spatio-temporal pattern**
with ``n‚ãÖm`` mean data matrix `X`,
``m‚ãÖm`` covariance matrices `C‚Çç‚ÇÅ‚Çé` and ``n‚ãÖn`` covariance matrix `C‚Çç‚ÇÇ‚Çé` as input.


`eVar`, `eVarC` and `eVarMeth` are keyword optional arguments
for defining the [subspace dimension](@ref) ``p``. Particularly:
-  `eVarC` is used for defining the subspace dimension of
   the whitening step. The default is 0.999.
- `eVar` is the keyword optional argument for defining the
   [subspace dimension](@ref) ``p`` using the `.arev` vector
   given by [cstp.5]. The default is given in [cstp.6] here above.
- `eVarMeth` applies to both `eVarC` and `eVar`. The default value is
   `evarMeth=searchsortedfirst`.

If `simple` is set to `true`, ``p`` is set equal to ``n``
and only the fields `.F` and `.iF` are written in the constructed object.
This option is provided for low-level work when you don't need to define
a subspace dimension or you want to define it by your own methods.

(2)
**Common spatio-temporal pattern**
with a set of ``k`` data matrices `ùêó` as input.

The ``k`` matrices in `ùêó` are real or complex data matrices.
They must all have the same size.

`covEst` and `meanX` are optional
keyword arguments to regulate the estimation of the
covariance matrices of the data matrices in `ùêó`,
to be used to compute the mean covariance matrices in [cstp.2] here above.
See [covariance matrix estimations](@ref).

The mean covariance matrices ``C_{(1)}`` and ``C_{(1)}`` in [cstp.2]
are computed using optional keywords arguments
`metric`, `w`, `‚úìw`, `init1`, `init2`, `tol` and `verbose`,
which allow to compute non-Euclidean means.
Particularly (see [mean covariance matrix estimations](@ref)),
- `init1` is the initialization for ``C_{(1)}``,
- `init2` is the initialization for ``C_{(2)}``.
By default, the arithmetic means [cstp.2] are computed.

Once the two covariance matrices ``C_{(1)}`` and ``C_{(2)}`` estimated,
method (1) is invoked with optional keyword arguments
`eVar`, `eVarC`, `eVarMeth` and `simple`.
See method (1) for details.

"""
function cstp( X :: Mat, C‚Çç‚ÇÅ‚Çé :: SorH, C‚Çç‚ÇÇ‚Çé :: SorH;
               eVar     :: TeVaro = ‚óã,
               eVarC    :: TeVaro = ‚óã,
               eVarMeth :: Function = searchsortedfirst,
               simple   :: Bool = false)

   d‚Çç‚ÇÇ‚Çé, d‚Çç‚ÇÅ‚Çé, d‚Çì=size(C‚Çç‚ÇÇ‚Çé, 1), size(C‚Çç‚ÇÅ‚Çé, 1), size(X)
   (d‚Çç‚ÇÅ‚Çé==d‚Çì[2] && d‚Çç‚ÇÇ‚Çé==d‚Çì[1]) || throw(ArgumentError(üìå*", cstp function: For n‚ãÖm matrix X, matrix C‚Çç‚ÇÅ‚Çé must be m‚ãÖm and matrix C‚Çç‚ÇÇ‚Çé n‚ãÖn"))
   args=("Common Spatio-Temporal Pattern", false)
   kwargs=(eVar=eVarC, eVarMeth=eVarMeth, simple=false)

   t=whitening(C‚Çç‚ÇÅ‚Çé; kwargs...)
   s=whitening(C‚Çç‚ÇÇ‚Çé; kwargs...)

   U, Œª, V = svd(s.F'*X*t.F; full=true)
   Œª = _checkŒª(Œª) # make sure no imaginary noise is present (fro complex data)

   simple ? LF([s.F*U, t.F*V], [U'*s.iF, V'*t.iF], Diagonal(Œª), ‚óã, ‚óã, ‚óã, args...) :
   begin
     #eVar===‚óã ? eVar=(2*norm(X)^2)/(tr(C‚Çç‚ÇÅ‚Çé)*size(X, 2)+tr(C‚Çç‚ÇÇ‚Çé)*size(X, 1)) : ‚óã
     #println(eVar)
     eVar, D, U, V, p, arev=_ssdcstp!(eVar, Œª, U, Matrix(V), _minDim(X), eVarMeth) # subspace dimension
     LF([s.F*U, t.F*V], [U'*s.iF, V'*t.iF], D, eVar, Œª, arev, args...)
   end
end

# no dims argument since it is the same for cstp
function cstp( ùêó::VecMat;
               covEst   :: StatsBase.CovarianceEstimator = SCM,
               meanX    :: Into = 0,
            eVar     :: TeVaro = ‚óã,
            eVarC    :: TeVaro = ‚óã,
            eVarMeth :: Function = searchsortedfirst,
            simple   :: Bool = false,
         metric   :: Metric = Euclidean,
         w        :: Vector = [],
         ‚úìw       :: Bool = true,
         init1     :: SorHo = nothing,
         init2     :: SorHo = nothing,
         tol      :: Real = 0.,
         verbose  :: Bool = false)

   Metric==VonNeumann && throw(ArgumentError(üìå*", cstp function: A solution for the mean is not available for the Von Neumann metric. Use another metric as `metric` argument"))
   covEst==SCM && metric ‚àâ (Euclidean, Wasserstein) && throw(ArgumentError(üìå*", cstp function: Only the Euclidean and Wasserstein `metric` can be used if the covariance estimator is `SCM`"))
   ùêÇ‚Çç‚ÇÅ‚Çé=_cov(ùêó; covEst=covEst, dims = 1, meanX = meanX)
   ùêÇ‚Çç‚ÇÇ‚Çé=_cov(ùêó; covEst=covEst, dims = 2, meanX = meanX)

   cstp(PosDefManifold.fVec(mean, Vector{Matrix}(ùêó)), # multi-threaded Euclidean mean
        mean(metric, ùêÇ‚Çç‚ÇÅ‚Çé;
             w = w, ‚úìw = ‚úìw,
             init = init1===‚óã ? ‚óã : Hermitian(init1), #just init here when you update PodDefManifold
             tol = tol, verbose = verbose),
        mean(metric, ùêÇ‚Çç‚ÇÇ‚Çé;
             w = w, ‚úìw = ‚úìw,
             init = init2===‚óã ? ‚óã : Hermitian(init2), #just init here when you update PodDefManifold.jl
             tol = tol, verbose = verbose),
        eVar     = eVar,
        eVarC    = eVarC,
        eVarMeth = eVarMeth,
        simple   = simple)
end
