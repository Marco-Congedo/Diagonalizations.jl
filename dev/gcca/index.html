<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>gCCA ¬∑ Diagonalizations</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Diagonalizations logo"/></a><div class="docs-package-name"><span class="docs-autofit">Diagonalizations</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Documentation</a></li><li><a class="tocitem" href="../Diagonalizations/">Diagonalizations</a></li><li><span class="tocitem">Filters</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">One dataset (m=1)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pca/">PCA</a></li><li><a class="tocitem" href="../whitening/">Whitening</a></li><li><a class="tocitem" href="../csp/">CSP</a></li><li><a class="tocitem" href="../cstp/">CSTP</a></li><li><a class="tocitem" href="../ajd/">AJD</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Two datasets (m=2)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../mca/">MCA</a></li><li><a class="tocitem" href="../cca/">CCA</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Several datasets (m&gt;2)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../gmca/">gMCA</a></li><li class="is-active"><a class="tocitem" href>gCCA</a></li><li><a class="tocitem" href="../majd/">mAJD</a></li></ul></li></ul></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Filters</a></li><li><a class="is-disabled">Several datasets (m&gt;2)</a></li><li class="is-active"><a href>gCCA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>gCCA</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Marco-Congedo/Diagonalizations.jl/blob/master/docs/src/gcca.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="gCCA-1"><a class="docs-heading-anchor" href="#gCCA-1">gCCA</a><a class="docs-heading-anchor-permalink" href="#gCCA-1" title="Permalink"></a></h1><p><em>Generalized Canonical Correlation Analysis</em> (gCCA) is a mutiple approximate joint diagonalization prodedure generalizing the canonical correlation analysis (<a href="../cca/#CCA-1">CCA</a>) to the situation <span>$m&gt;2$</span> (number of datasets), as for CCA with <span>$k=1$</span> (one observation). As the CCA is an <a href="../mca/#MCA-1">MCA</a> carried out on whitened data, so the gCCA is a <a href="../gmca/#gMCA-1">gMCA</a> carried out on whitened data.</p><p>Let <span>${X_1,...,X_m}$</span> be a set of <span>$m$</span> data matrices of dimension <span>$n‚ãÖt$</span>, where <span>$n$</span> is the number of variables and <span>$t$</span> the number of samples, both common to all datasets. From these data matrices let us estimate</p><p><span>$C_{ij}=\frac{1}{T}X_iX_j^H$</span>, for all <span>$i,j‚àà[1...m]$</span>, <span>$\hspace{1cm}$</span> [gcca.1]</p><p>i.e., all <em>covariance</em> (<span>$i=j$</span>) and <em>cross-covariance</em> (<span>$i‚â†j$</span>) matrices.</p><p>The gMCA seeks <span>$m$</span> matrices <span>$F_1,...,F_m$</span> diagonalizing as much as possible all products</p><p><span>$F_i^H C_{ij} F_j$</span>, for all <span>$i‚â†j‚àà[1...m]$</span>. <span>$\hspace{1cm}$</span> [gcca.2]</p><p>under costraint</p><p><span>$F_i^H C_{ii} F_i=I$</span>, for all <span>$i‚àà[1...m]$</span>. <span>$\hspace{1cm}$</span> [gcca.3]</p><h4 id="permutation-for-gCCA-1"><a class="docs-heading-anchor" href="#permutation-for-gCCA-1">permutation for gCCA</a><a class="docs-heading-anchor-permalink" href="#permutation-for-gCCA-1" title="Permalink"></a></h4><p>Given constraint [gcca.3], the scaling of approximate diagonalizers <span>$F_1,...,F_m$</span> are fixed, however there is still a sign and permutation ambiguity (see <a href="../Diagonalizations/#scale-and-permutation-1">scale and permutation</a>). <em>Diagonalizations.jl</em> attempts to solve them by finding signed permutation matrices for <span>$F_1,...,F_m$</span> so as to make all diagonal elements of [gcca.2] positive and sorted in descending order.</p><p>Let</p><p><span>$Œª=[Œª_1...Œª_n]$</span>  <span>$\hspace{1cm}$</span> [gcca.4]</p><p>be the diagonal elements of</p><p><span>$\frac{1}{m^2-m}\sum_{i‚â†j=1}^m(F_i^H C_{ij} F_j)$</span> <span>$\hspace{1cm}$</span> [gcca.5]</p><p>and <span>$œÉ_{TOT}=\sum_{i=1}^nŒª_i$</span> be the total correlation.</p><p>We denote <span>$\widetilde{F}_i=[f_{i1} \ldots f_{ip}]$</span> the matrix holding the first <span>$p&lt;n$</span> column vectors of <span>$F_i$</span>, where <span>$p$</span> is the <a href="../Diagonalizations/#subspace-dimension-1">subspace dimension</a>. The <em>explained variance</em> is given by</p><p><span>$œÉ_p=\frac{\sum_{i=1}^pŒª_i}{œÉ_{TOT}}$</span> <span>$\hspace{1cm}$</span> [gcca.6]</p><p>and the <em>accumulated regularized eigenvalues</em> (arev) by</p><p><span>$œÉ_j=\sum_{i=1}^j{œÉ_i}$</span>, for <span>$j=[1 \ldots n]$</span>, <span>$\hspace{1cm}$</span> [gcca.7]</p><p>where <span>$œÉ_i$</span> is given by Eq. [gcca.6].</p><p>For setting the subspace dimension <span>$p$</span> manually, set the <code>eVar</code> optional keyword argument of the gCCA constructors either to an integer or to a real number, this latter establishing <span>$p$</span> in conjunction with argument <code>eVarMeth</code> using the <code>arev</code> vector (see <a href="../Diagonalizations/#subspace-dimension-1">subspace dimension</a>). By default, <code>eVar</code> is set to 0.999.</p><p><strong>Solution</strong></p><p>There is no closed-form solution to the AJD problem in general. See <a href="../algorithms/#Algorithms-1">Algorithms</a>.</p><p>Note that solving algorithms constraining the solution to the general linear group, like <em>NoJoB</em>, do not suit gCCA as they do not ensure constraint [gcca.2].</p><p><strong>Constructors</strong></p><p>One constructor is available (see here below). The constructed <a href="../Diagonalizations/#LinearFilter-1">LinearFilter</a> object holding the gCCA will have fields:</p><p><code>.F</code>: vector of matrices <span>$\widetilde{F}_1,...,\widetilde{F}_m$</span> with columns holding the first <span>$p$</span> eigenvectors in <span>$F_1,...,F_m$</span>, or just <span>$F_1,...,F_m$</span> if <span>$p=n$</span></p><p><code>.iF</code>: the vector of the left-inverses of the matrices in <code>.F</code></p><p><code>.D</code>: the leading <span>$p‚ãÖp$</span> block of <span>$Œõ$</span>, i.e., the elements [gcca.4] associated to the matrices in <code>.F</code> in diagonal form.</p><p><code>.eVar</code>: the explained variance [gcca.6] for the chosen value of <span>$p$</span>.</p><p><code>.ev</code>: the vector <span>$Œª$</span> [gcca.4].</p><p><code>.arev</code>: the accumulated regularized eigenvalues, defined by [gcca.7]</p><article class="docstring"><header><a class="docstring-binding" id="Diagonalizations.gcca" href="#Diagonalizations.gcca"><code>Diagonalizations.gcca</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function gcca(ùêó::VecMat;
              covEst     :: StatsBase.CovarianceEstimator = SCM,
              dims       :: Into    = ‚óã,
              meanX      :: Into    = 0,
          algorithm :: Symbol    = :OJoB,
          sort      :: Bool      = true,
          init      :: VecMato   = ‚óã,
          tol       :: Real      = 0.,
          maxiter   :: Int       = _maxiter(algorithm, eltype(ùêó[1])),
          verbose   :: Bool      = false,
        eVar     :: TeVaro   = _minDim(ùêó),
        eVarMeth :: Function = searchsortedfirst,
        simple   :: Bool     = false)
</code></pre><p>Return a <a href="../Diagonalizations/#LinearFilter-1">LinearFilter</a> object.</p><p><strong>Generalized Canonical Correlation Analysis</strong> of the set of <span>$m$</span> data matrices <code>ùêó</code> using the given solving <code>algorithm</code> (<em>OJoB</em> by default).</p><p>If <code>sort</code> is true (default), the column vectors of the matrices <span>$F_1,...,F_m$</span> are signed and permuted as explained here above in <a href="#permutation-for-gCCA-1">permutation for gCCA</a>, otherwise they will have arbitrary sign and will be in arbitrary order.</p><p>Regarding arguments <code>init</code>, <code>tol</code> and <code>maxiter</code>, see <a href="../algorithms/#Algorithms-1">Algorithms</a>.</p><p>If <code>verbose</code> is true (false by default), the convergence attained at each iteration will be printed in the REPL.</p><p><code>eVar</code> and <code>eVarMeth</code> are used to define a <a href="../Diagonalizations/#subspace-dimension-1">subspace dimension</a> <span>$p$</span> using the accumulated regularized eigenvalues in Eq. [gcca.7]</p><p>The default values are:</p><ul><li><code>eVar</code> is set to the minimum dimension of the matrices in <code>ùêó</code></li><li><code>eVarMeth=searchsortedfirst</code></li></ul><p>If <code>simple</code> is set to <code>true</code>, <span>$p$</span> is set equal to the dimension of the covariance matrices that are computed on the matrices in <code>ùêó</code>, which depends on the choice of <code>dims</code>, and only the fields <code>.F</code> and <code>.iF</code> are written in the constructed object. This corresponds to the typical output of approximate diagonalization algorithms.</p><p><strong>See also:</strong> <a href="../mca/#MCA-1">MCA</a>, <a href="#gCCA-1">gCCA</a>, <a href="../majd/#mAJD-1">mAJD</a>.</p><p><strong>Examples:</strong></p><pre><code class="language-none">using Diagonalizations, LinearAlgebra, PosDefManifold, Test


####  Create data for testing the case k=1, m&gt;1
# `t` is the number of samples,
# `m` is the number of datasets,
# `n` is the number of variables,
# `noise` must be smaller than 1.0. The smaller the noise,
#  the more data are correlated.
function getData(t, m, n, noise)
    # create m identical data matrices and rotate them by different
    # random orthogonal matrices V_1,...,V_m
    ùêï=[randU(n) for i=1:m] # random orthogonal matrices
    X=randn(n, t)  # data common to all subjects
    # each subject has this common part plus a random part
    ùêó=[ùêï[i]&#39;*((1-noise)*X + noise*randn(n, t)) for i=1:m]
    return ùêó
end

function getData(::Type{Complex{T}}, t, m, n, noise) where {T&lt;:AbstractFloat}
    # create m identical data matrices and rotate them by different
    # random orthogonal matrices V_1,...,V_m
    ùêï=[randU(ComplexF64, n) for i=1:m] # random orthogonal matrices
    X=randn(ComplexF64, n, t)  # data common to all subjects
    # each subject has this common part plus a random part
    ùêó=[ùêï[i]&#39;*((1-noise)*X + noise*randn(ComplexF64, n, t)) for i=1:m]
    return ùêó
end

# REAL data: check that for the case m=2 gCCA gives the same result as CCA
t, m, n, noise = 20, 2, 6, 0.1
Xset=getData(t, m, n, noise)
Cx=(Xset[1]*Xset[1]&#39;)/t
Cy=(Xset[2]*Xset[2]&#39;)/t
Cxy=(Xset[1]*Xset[2]&#39;)/t

gc=gcca(Xset; simple=true)

c=cca(Hermitian(Cx), Hermitian(Cy), Cxy; simple=true)

@test (c.F[1]&#39;*Cxy*c.F[2]) ‚âà (gc.F[1]&#39;*Cxy*gc.F[2])
@test gc.F[1]&#39;*Cx*gc.F[1]‚âàI
@test gc.F[2]&#39;*Cy*gc.F[2]‚âàI
D=gc.F[1]&#39;*Cxy*gc.F[2]
@test norm(D-Diagonal(D))+1‚âà1.


# COMPLEX data: check that for the case m=2 gCCA gives the same result as CCA
t, m, n, noise = 20, 2, 6, 0.1
Xcset=getData(ComplexF64, t, m, n, noise)
Ccx=(Xcset[1]*Xcset[1]&#39;)/t
Ccy=(Xcset[2]*Xcset[2]&#39;)/t
Ccxy=(Xcset[1]*Xcset[2]&#39;)/t

gcc=gcca(Xcset; simple=true)
cc=cca(Hermitian(Ccx), Hermitian(Ccy), Ccxy; simple=true)

# for complex data just do a sanity check as the order of vectors
# is arbitrary. The following two tests currently fail
# @test spForm(cc.F[1]&#39;gcc.F[1])&lt;0.001
# @test spForm(cc.F[2]&#39;gcc.F[2])&lt;0.001

@test gcc.F[1]&#39;*Ccx*gcc.F[1]‚âàI
@test gcc.F[2]&#39;*Ccy*gcc.F[2]‚âàI
# sanity check only as there is noise in the complex case
D=gcc.F[1]&#39;*Ccxy*gcc.F[2]
@test norm(D-Diagonal(D))/(n^2-n)&lt;0.001


# REAL data: m&gt;2 case
t, m, n, noise = 20, 4, 6, 0.1
Xset=getData(t, m, n, noise)

# ... selecting subspace dimension allowing an explained variance = 0.9
gc=gcca(Xset, eVar=0.9)

# name of the filter
gc.name

ùíû=Array{Matrix}(undef, 1, m, m)
for i=1:m, j=1:m ùíû[1, i, j]=(Xset[i]*Xset[j]&#39;)/t end

using Plots
# plot regularized accumulated eigenvalues
plot(gc.arev)


# plot the original cross-covariance matrices and the rotated
# cross-covariance matrices

# Get all products ùêî[i]&#39; * ùíû[l, i, j] * ùêî[j]
function _rotate_crossCov(ùêî, ùíû, m, k)
    ùíÆ=Array{Matrix}(undef, k, m, m)
    @inbounds for l=1:k, i=1:m, j=1:m ùíÆ[l, i, j]=ùêî[i]&#39;*ùíû[l, i, j]*ùêî[j] end
    return ùíÆ
end


# Put all cross-covariances in a single matrix of dimension m*n x m*n for visualization
function ùíû2Mat(ùíû::AbstractArray, m, k)
    n=size(ùíû[1, 1, 1], 1)
    C=Matrix{Float64}(undef, m*n, m*n)
    for i=1:m, j=1:m, x=1:n, y=1:n C[i*n-n+x, j*n-n+y]=ùíû[k, i, j][x, y] end
    return C
end

 C=ùíû2Mat(ùíû, m, 1)
 Cmax=maximum(abs.(C));
 h1 = heatmap(C, clim=(-Cmax, Cmax), yflip=true, c=:bluesreds, title=&quot;all cross-covariances&quot;)
 ùíÆ=_rotate_crossCov(gc.F, ùíû, m, 1)
 S=ùíû2Mat(ùíÆ, m, 1)
 h2 = heatmap(S, clim=(0, 1), yflip=true, c=:amp, title=&quot;all rotated cross-covariances&quot;)
 üìà=plot(h1, h2, size=(700,300))
# savefig(üìà, homedir()*&quot;\Documents\Code\julia\Diagonalizations\docs\src\assets\FiggCCA.png&quot;)
</code></pre><p><img src="../assets/FiggCCA.png" alt="Figure gCCA"/></p><p>In the figure here above, the rotated cross-covariance matrices have the expected   <em>strip-diagonal</em> form, that is, each block <span>$F_i^T\frac{1}{T}(X_iX_j^T)F_j$</span>,   for <span>$i,j‚àà[1,...,m]$</span>, is approximately diagonal. Each block is <span>$6‚ãÖ6$</span> because   setting <code>eVar=0.9</code> has not reduced the original dimension.   The solution is similar to the <a href="../gmca/#gMCA-1">gMCA</a>, but here the diagonal   of the rotated block matrix is the identity.</p><pre><code class="language-none"># COMPLEX data: m&gt;2 case
t, m, n, noise = 20, 4, 6, 0.1
Xcset=getData(ComplexF64, t, m, n, noise)

# ... selecting subspace dimension allowing an explained variance = 0.9
gcc=gcca(Xcset, eVar=0.9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Marco-Congedo/Diagonalizations.jl/blob/f9b1117211e0c6e576eefaf9c3efc21813802692/src/gcca.jl#L240-L431">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gmca/">¬´ gMCA</a><a class="docs-footer-nextpage" href="../majd/">mAJD ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 January 2020 11:26">Monday 13 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
